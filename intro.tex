For decades, applications enjoyed automatic and regular performance gains from increasingly faster CPU speed.  However, this trend has stopped permanently because of hard physical limits. Increasing CPU speed results in consuming more energy and generating more heat, adding to their operating cost. Intel and other vendors have turned to providing more and more cores on a single machine, which brings us multi-core era. The appearance of multi-core drives the biggest revolution of software development: software has to be programmed in a concurrent and parallel way in order to exploit the benefits of multi-core machines.

Building efficient and reliable concurrent software is still a challenging task because of the following reasons. First, concurrency requires programmers to think in an unnatural way that humans find difficult.  Second, existing languages and tools are inadequate to detect or prevent concurrency errors and performance anomalies. 

% Why we need determinism? Concurrency errors?
Concurrency errors of multithreading programs, such as race conditions, atomicity violations, order violations and deadlocks, are very hard to debug ~\cite{Lu:2008:LMC:1346281.1346323}, because their occurrences highly depend on some specific conditions, such as thread interleavings and CPU scheduling ~\cite{DBLP:conf/icse/BallBHMQ09,DBLP:conf/asplos/BurckhardtKMN10}. Instead of detecting possible concurrency errors, one promising alternative approach is to attack the problem of concurrency bugs by eliminating its source: non-determinism. A fully \emph{deterministic multithreading system} would prevent Heisenbugs by ensuring that executions of the same program with the same inputs always yield the same results, even in the face of race conditions in the code. Such a system would not only dramatically simplify debugging of concurrent
programs~\cite{Carver:1991:RTC:624586.625040} and reduce their attendant testing overhead, but would also enable a number of other applications. For example, a deterministic multithreaded system would greatly simplify record and replay for multithreaded programs~\cite{Choi:1998:DRJ:281035.281041,LeBlanc:1987:DPP:32387.32396} and the execution of multiple replicas of multithreaded applications for fault tolerance~\cite{deterministic-process-groups,1134000,224058,replicant-hotos}.

% Why we need to find out false sharing problems.
Besides concurrency errors, writing efficient multithreading programs remains challenging now. False sharing problem is one of notorious performance problem inside multithreading programs. It occurs when multiple threads, running on different cores with separate caches, are accessing logically independent words in the same cache line. If a thread modify something inside a cache line, cache coherence protocol invalidates the duplicates of this cache line in other caches in order to guarantee a correct execution of a program, which is crucial for true sharing cases. However, it is totally unnecessary for false sharing cases. False sharing problem can force one core to wait unnecessarily for updates from another processor, thus waste both the CPU time and precious memory bandwidth in the same time. False sharing is a well-known performance issue~\cite{falseshare:Analysis, falseshare:effect}. 

\subsection*{Contributions}

This thesis handles two categories of problems inside multithreading programs, the reliability problem and the performance problem, and makes the following contributions:

\begin{itemize}
\item \Sheriff{} framework: I developed a novel processes-as-threads framework by borrowing the idea from Grace~\cite{grace}. \sheriff{} is a software-only framework that replaces the standard pthreads library and transforms
threads into processes, with separate address spaces but the shared file table. \sheriff{} provides per-thread memory protection and isolation on the page granularity. It can also track memory writes on a per-page basis, by utilizing standard memory protection mechanism and  twining-and-diffing mechanism. \sheriff{} enables a range of possible applications, including language support and enforcement of data sharing, software transactional memory, thread-level speculation, and race detection. 

\item I developed an efficient deterministic multithreading system, \dthreads{}~\cite{dthreads}, for unmodified C/C++ applications by replacing the existing \pthreads{} library. \dthreads{} is based on the \sheriff{} framework to isolate executions of different threads. \dthreads{} outperforms the previous state-of-the-art runtime system (CoreDet) by a factor of 3, and often matches and sometimes exceeds the performance with the standard \pthreads{} library. \Dthreads{} enforces robust/stable determinism even in the face of data races, greatly simplifying program understanding and debugging: programs always behave the same, even with different inputs and on different hardware, as long as the synchronization order is staying the same. Because of this, \dthreads{} can also be used to support \textbf{replicated executions} 
of multithreaded applications for fault tolerance purposes.

\item 
Based on \sheriff{} framework, I developed two tools, \SheriffDetect{} and \SheriffProtect{}, to deal with false sharing problems
of multithreaded programs, one of notorious performance problems. 
\SheriffDetect{} can find instances of false sharing that can cause serious performance problems. \SheriffDetect{} is accurate (no false positives), runs with low overhead (on average 20\%), and can precisely pinpoint the exact objects involved in false sharing.
\SheriffProtect{} mitigates false sharing problems by adaptively isolating shared 
updates from different threads into separate physical addresses, effectively 
eliminating the performance impact of false sharing. It can boost the performance automatically for those multithreaded applications, without the need of programmers interventions. 

\item I also developed a tool, \predator{}, to improve the effectiveness and overcome a key  limitation of false sharing detection. Instead of relying on \sheriff{} framework to track memory accesses, \predator{} employs compiler instrumentation to track memory accesses. This make it possible to detect one more type of false sharing - read-write false sharing problems. \Predator{} also overcomes a key limitation of previous detection tools: it can predict potential false sharing that does not manifest in a given execution but may appear-and greatly degrade application performanceâ€”in a slightly different execution environment. \Predator is the first false sharing tool able to automatically and precisely uncover false sharing problems in real applications, including MySQL and the Boost library.


\end{itemize}

\subsection*{Outline}
The rest of this proposal is organized as follows. Chapter~\ref{chapter:problems} describes the reliability and performance problems of writing multithreaded programs, which we are going to handle in this thesis. Chapter~\ref{sec:sheriffframework} describes the processes-as-threads framework, which is the basis for \dthreads{}, \SheriffDetect{} and \SheriffProtect{}. Chapter~\ref{chapter:dthreads} describes\dthreads{}, which ensures deterministic execution for multithreading programs linking to this drop-in library. Chapter~\ref{chapter:sherifftools} discusses how to build precisely detecting and automatically tolerating false sharing based on \sheriff{} framework. Chapter~\ref{chapter:preditor} describes a generalized false sharing detection tool by combining compiler instrumentation and runtime system, which improves the effectiveness of detection. 
Chapter~\ref{chapter:relatedwork} provides a substantial comparison between previous work and our approaches and Chapter~\ref{chapter:conclusion} concludes the thesis with its contributions. 


%%
%% Some sample text

