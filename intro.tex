For decades, applications enjoyed automatic and regular performance gains from increasingly faster CPU speed.  However, this trend has stopped permanently because of hard physical limits. Computer manufacturers have turned to providing more and more cores on a single machine. This phenomenon drives the biggest revolution of software development: software has to be programmed in a concurrent and parallel way in order to exploit the benefits of multi-core machines.Building efficient and reliable concurrent software is still a challenging task because of the following reasons. First, concurrency requires programmers to think in an unnatural way that humans find difficult.  Second, existing languages and tools are inadequate to detect or prevent concurrency errors and performance anomalies. 

% Why we need determinism? Concurrency errors?
In multithreaded environment, there exists a range of concurrency errors, such as race conditions, atomicity violations, order violations and deadlocks. These concurrency errors makes the program very hard to debug and reasoning because their occurrences highly depend on some specific conditions, such as thread interleavings and CPU scheduling. 

% Why we need to find out false sharing problems. 
Multithreaded applications are still susceptible to concurrency errors and performance anomalies, which are notoriously difficult to debug. 

First, it is hard to write correct multithreaded programs.  
Because the execution of a program depends on thread interleavings, which happen randomly and differently, programs may run differently in different executions. Even worse, those concurrency errors are difficult to reproduce. This non-deterministic behavior makes it hard to understand and debug multi-threaded programs.

Second, it is very difficult to write efficient multithreaded programs. False sharing is one of insidious problems for multithreaded programs running on multicore processors, where it can silently degrade performance and scalability. Worse, some common programming practice can easily cause false sharing problems.


My thesis addresses these difficulties and make the following contributions:

\begin{itemize}
\item \Dthreads{}:
I developed an efficient deterministic multithreading system, \dthreads{}~\cite{dthreads}, for unmodified C/C++ applications by replacing the existing \pthreads{} library.
\dthreads{} outperforms the previous state-of-the-art runtime system (CoreDet) by a factor of 3, and often matches and sometimes exceeds the performance with the standard \pthreads{} library. \Dthreads{} enforces robust/stable determinism even in the face of data races, 
greatly simplifying program understanding and debugging: 
programs always behave the same, even with different inputs and on different hardware, as long as the synchronization order is staying the same. Because of this, \dthreads{} can also be used to support \textbf{replicated executions} 
of multithreaded applications for fault tolerance purposes.

\item \Sheriff{}:
%\item \textbf{\Sheriff{}}:
We provide two tools to deal with false sharing problems
of multithreaded programs based on the same \Sheriff{} framework~\cite{sheriff}, by extending the \emph{processes-as-threads} concept introduced in our Grace paper~\cite{grace}.
\sheriff{} replaces threads with processes, with the shared file descriptor table. It framework allows programs to perform per-thread memory isolation and track writes on a per-page basis, by utilizing standard memory protection mechanism and  twining-and-diffing mechanism.
Built on this framework, \SheriffDetect{} can find instances of false sharing that can cause serious performance problems. 
\SheriffDetect{} is accurate (no false positives), runs with low overhead (on average 20\%), and can precisely pinpoint the exact objects involved in false sharing.
\SheriffProtect{} mitigates false sharing problems by adaptively isolating shared 
updates from different threads into separate physical addresses, effectively 
eliminating the performance impact of false sharing. 
%\textbf{Real Impact}:\sheriffDetect{} is a open-source project on GitHub and is 
%utilized by the \textbf{SAS} and \textbf{Intel} company to locate false sharing 
%problems inside their products. 

%\SheriffProtect{} 
%can be used in the following cases: it is infeasible to fix false sharing problems 
%when source is unavailable, or undesirable when padding objects would unacceptably 
%increase memory consumption or further worsen runtime performance. 



%\sheriff{} framework provides a per-thread-isolation functionality, which is perfectly suitable
%for the determinism purpose since a thread's modifications won't be seen by other threads.


%\dthreads{} works by exploding multithreaded applications into multiple processes, with 
%private, copy-on-write mappings to the same shared memory, isolating the memory writes from different threads. 
%It then uses standard virtual memory protection to track writes, and deterministically orders updates by each thread. 
%By isolating updates from different threads, \dthreads{} has the additional benefit of eliminating false sharing.

%\sheriff{} framework provides a per-thread-isolation functionality, which is perfectly suitable 
%for the determinism purpose since a thread's modifications won't be seen by other threads.
%Building on \sheriff{} framework, \dthreads{} isolates memory accesses, commits threads' updates 
%in a deterministic order and synchronizes threads deterministically.

\item \DoubleTake{}:
We propose \DoubleTake{} to detect \textbf{write-write} races effectively, precisely, and efficiently.
\DoubleTake{} verifies all write accesses inside the same epoch, while 
concurrent accesses from different threads inside the same epoch are considered
to be races. In order to locate races precisely, \DoubleTake{} re-executes programs after installing 
watch points on problematic memory addresses. 
Since \DoubleTake{} only checks memory errors at boundaries of synchronizations and system calls,
instead of before every memory access like traditional approaches, 
the overhead of \DoubleTake{} can be amortized over a long execution time. 
To replay the executions of  multithreaded programs, we
are planning to built \DoubleTake{} on top of the \dthreads{} framework.
% Most of existing tools to detect races are based on a pess 
% to achieve the determinism target.
  
%Whenever some memory errors detected, like races or buffer overflows, 
%we can re-execute the program and utilize the hardware watchpoints to 
%locate the origin of problems precisely. 
%We have finished a practical buffer overflow detection tool for single-threaded program, which only
%introduces negligible performance overhead (about 2\%), much lower than the state-of-the-art technique. 
%The state-of-the-art tool to detect the buffer overflow problem,  
%AddressSanitizer from \texttt{Google}, introduces about 26\% performance overhead.

%However, checking memory errors using this technique for multithreaded programs
% is much more complicated 
%than that for single-threaded programs. 
%Because numerous possible thread interleavings can happen in the re-execution phase, we should  
%ensure deterministic rollbacks of the programs in order to precisely locate
%the memory errors.
%We are proposing to rely on the \dthreads{} framework to achieve this determinism target.
%By combining with \dthreads{} and watchpoint technique, we can find out those memory errors in some specific
%scheduling order, which also verify one claim of determinism: 
%deterministic system is useful to locate the memory errors.

\end{itemize}

The rest of this proposal is organized as follows. Chapter 1 introduces 
difficulties to write multithreaded programs. 
Chapter 2 provides an overview of previous work on these existing problems. 
Chapter 3 and chapter 4 discuss our existing systems, \sheriff{} and \dthreads{}.
Chapter 5 proposes the basic idea and challenges to design an efficient memory debugging system, \DoubleTake{}. 

%%
%% Some sample text

