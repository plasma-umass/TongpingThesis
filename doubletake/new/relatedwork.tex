In this section, we discuss related approaches to dynamic analysis and efficient record and replay systems.

\subsection{Dynamic Analysis}
Dynamic analyses typically rely on one or more of the following approaches: dynamic instrumentation, static instrumentation, and interposition. We discuss prior analysis tools below, grouped by approach.

\subsubsection*{Dynamic Instrumentation} 
A large number of error detection tools use dynamic instrumentation, including many commercial tools. Valgrind's Memcheck tool, Dr. Memory, Purify, Intel Inspector, and Sun Discover all fall into this category~\cite{ overflow:drmemory, overflow:purify, overflow:inspector, overflow:valgrind, overflow:discover}. These tools use dynamic instrumentation engines, such as Pin, Valgrind, and DynamiRIO~\cite{DynamoRIO, Pin, overflow:valgrind}. These tools can detect memory leaks, use-after-free errors, uninitialized reads, and buffer overflows. Dynamic analysis tools are typically easy to use because they do not require recompilation, but this easy of use comes at the cost of high overhead. Programs run with Valgrind take $20\times$ longer than usual, and Dr. Memory introduces $10\times$ runtime overhead. \doubletake{} is \emph{significantly} more efficient than prior dynamic instrumentation tools.

\subsubsection*{Static Instrumentation}
Static instrumentation-based techniques leverage compiler analyses and efficient code generation to implement more efficient dynamic analyses tools. Mudflap instruments references through pointers to detect buffer overflows, invalid heap usage, and memory leaks~\cite{overflow:Mudflap}. AddressSanitizer, CCured, LBC, Insured++, and Baggy bounds-checking leverage static analysis to reduce the amount of instrumentation~\cite{overflow:Baggy, overflow:lbc,  overflow:ccured, AddressSanitizer}. Compared to dynamic instrumentation-based approaches, these tools incur substantially lower overhead than dynamic instrumentation-based approaches, but are more difficult to use. Tools that rely on static instrumentation cannot detect errors in code that was not recompiled with instrumentation. \doubletake{} is more efficient than AddressSanitizer, the previous state-of-the-art, and enables dynamic analysis on the entire program (including libraries) with no recompilation.

\subsubsection*{Interposition}
\doubletake{} uses library interposition exclusively during normal execution. More expensive instrumentation is only introduced after an error has been detected. BoundsChecker interposes on Windows heap library calls to detect memory leaks, use-after-free errors and buffer overflows~\cite{BoundsChecker}. Many prior approaches use a mix of library interposition and virtual memory techniques to detect memory errors~\cite{duma, Sleigh, Undangle, SWAT, Dlmalloc, GuardMalloc, exterminator, Hound, electricfence, overflow:Cruiser}. Unlike \doubletake{}, the overhead of these systems remains high.
 
\subsection{Record-and-Replay}
Record and replay systems have broad applications. There are numerous replay-based approaches to software debugging and fault tolerance~\cite{Bressoud:1995:HFT:224056.224058, OSDebug, Rx, RecPlay, Flashback, Triage}. Flashback records the results of every system call to facilitate deterministic replay, but with higher overhead than \doubletake{}~\cite{Flashback}. \doubletake{} records only the necessary system state, and ``undoes'' the effect of system calls before re-execution. Triage automates the failure diagnosis process, but must be activated manually when an error is observed~\cite{Triage}. Aftersight and Speck use record and replay for dynamic analysis, but incur substantially higher overhead than \doubletake{}~\cite{Aftersight, Speck}. Aftersight executes programs in a virtual machine, and records all inputs to the VM. Speck is focused on security checks, including dataflow tracking and virus scanning: applications that likely require the always-on instrumentation that \doubletake{} does not provide. Other systems have focused on reducing the performance overhead of recording~\cite{ODR, Respec, PRES, DoublePlay}. None of these systems is as efficient as \doubletake{}.
