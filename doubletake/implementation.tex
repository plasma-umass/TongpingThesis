\label{sec:implementation}

This section describes the implementation of \doubletake{}, organized by the phases shown in Figure~\ref{fig:phases}. 

% we should say why we have normal execution and re-execution.
\doubletake{} divides the execution of a program to different epochs at the boundary of irrevocable system calls. At each epoch, \doubletake{} takes a snapshot of the program in the beginning and lets an application run at full speed until irrevocable system calls (in the end of this epoch), while recording some of the program's operations to facilitate re-execution. Then \doubletake{} examines the state for evidence of possible memory errors. 
If there is no evidence of errors, \doubletake{} issues this system call and enters into next epoch. If there is an error detected, \doubletake{} rolls back the program to the most recent checkpoint and re-executes the program to locate the exact cause of this error. 

\subsubsection{Epoch Start}
{\em Snapshot}. 
At the beginning of every epoch, \doubletake{} take a snapshot of the current program state 
so that we can rollback to this state if there are some errors detected at the end of the current epoch. A snapshot includes the state of registers (obtained using \texttt{getcontext()}),
and all writable memory, including the globals, the stack and the program heap. 
Read-only memory, such as text segments of a program and libraries, does not need to 
be saved in the snapshot. \doubletake{} analyzes the Linux file \texttt{/proc/self/map} 
to identify the ranges of the globals and the stack. Because of using a customized memory allocator, \doubletake{} knows the range of the heap. 

To save the snapshot, \doubletake{} saves the globals, heap, and stack before it calls \texttt{getcontext} to save its execution context. Also, \doubletake{} records file positions of all opening files. This lets programs issue \texttt{read} and \texttt{write} system calls without 
ending the current epoch. \doubletake{} uses the saved memory state, register state and file positions to ``undo'' an epoch if errors are found in the end of the current epoch. 

\subsubsection{Inside An Epoch}
\label{sec:inepoch}
Inside an epoch, \doubletake{} lets a program execute normally. But \doubletake{} interposes  library functions involving in system calls and heap allocations in order to set tripwires and support re-execution.

\paragraph{System Calls.}

\label{sec:syscall}

% Why we need to care about system calls. Because some system calls are irrevocable.
% However, not all IO are irrevocable. For example, if a file reads twice, as long as 
% it returns the same result. We do not need to undone the results of IO operations. 
\doubletake{} ends epochs on irrevocable system calls: the execution before
and after irrecocable system calls belong to different epochs.
Irrevocable here has a different meaning as that in transactional memory programming.
In transactional memory programming, irrevocable actions include IO and system calls whose
effect cannot be rollbacked or completely invoked in user space~\cite{Irrevocabletrans}.
\doubletake{} relaxes the definition of irrevocable: only the results of system calls cannot be
reproduced are considering to be irrevocable system calls.
System calls are classified to the following types.

\paragraph{Repeatable system calls} do not modify system state, and will always return the same result.
This category includes \texttt{sleep}, \texttt{pause}, and system calls to query system's state, e.g. \texttt{getpid()}, \texttt{fstat} and \texttt{stat}.
\doubletake{} does not need any special handling for these system calls.

\paragraph{Recordable system calls} may return different results if they are re-executed.
\doubletake{} records the result of these system calls.
During re-execution, \doubletake{} will simply return the saved result
instead of re-executing the system call.
This category includes \texttt{mmap()}, \texttt{gettimeofday()}, \texttt{time()}, and \texttt{clone()}.

\paragraph{Checkpointable system calls} modify system state,
but \doubletake{} can save this state beforehand and restore it prior to re-execution.
Most of file IO related system calls fall into this category.
For example, the \texttt{write()} system call can modify the contents of a file and moves the
file positions inside operating system.
They can be treated as irrevocable system calls, but that can greatly affect performance

For example, the \texttt{write()} system call can modify the contents of a file and moves the
file positions inside operating system.
They can be treated as irrevocable system calls, but that can greatly affect performance
because of intensive usages in applications.
\doubletake{} saves those file positions of openning files in the beginning of each epoch and
recovers those file positions before re-execution.
%Because \texttt{read()} and \texttt{write()} can be used in socket communications, which is considered
%as irrevocable system calls, \doubletake{} checks whether those file descriptors are related to 
%actual files. If they are invoked on actual files, there is no other operation on those file related system calls.  

\paragraph{Delayable system calls} will irrevocably change program state, but can safely
be delayed until the end of the current epoch.
\doubletake{} delays all calls to \texttt{munmap()} and \texttt{close()}.

\paragraph{Irrevocable system calls} cannot be replayed. \doubletake{} must end the current epoch
before these system calls are allowed to proceed. A system call not belonging to previous categories
can be conservatively treated as an irrevocable system call.

For checkpointable system calls, e.g., \texttt{read} and \texttt{write}, since they can 
also be called in socket communications, \doubletake{} has to check whether they 
are working on normal files. In order to speed up the checking process, \doubletake{] is using a hash map to hold file descriptors of all opening files. 
For normal files, reads and writes can be issued normally. 
For reads and writes in network communications, \doubletake{}  ends the current epochs since they are considered to be irrevocable system calls.

For recordable system calls, e.g., \texttt{gettimeofday}, \texttt{time}, and \texttt{mmap},
\doubletake{} records the results of system calls in a First-In-First-Out list, which are necessary to be replayed in re-execution phase if memory errors are detected at the end of the current epoch. 
For \texttt{open}-like library calls, \doubletake{} not only records file descriptors returned by system calls,
but also adds them to the hash map discussed above.  

For delayable system calls, e.g., \texttt{munmap} and \texttt{close}, they are added into a global 
list and are issued in the end of the current epoch after checkings of memory errors.

\subsubsection{Ending an Epoch}
At the end of each epoch, \doubletake{} checks the program state for errors. 
We have implemented error detection for heap buffer overflows (Section~\ref{sec:overflow}), 
memory leakage (Section~\ref{sec:leak}),
and memory use-after-free errors (Section~\ref{sec:danglingpointer}).

When \doubletake{} do not find any memory error, it issues all delayable system calls 
and cleans corresponding lists.
\doubletake{} also cleans recordable system calls
since there is no need to replay those system calls any more.
 
If \doubletake{} finds any memory error, it switches to the re-execution mode, discussed in Section\ref{sec:re-execution}.

\subsection{Rollback and Re-Execution}
\label{sec:re-execution}
When \doubletake{} detects an error, it uses rollback and re-execution to collect additional information to aid programmers in correcting the error. This additional information is either impossible or expensive to collect during normal execution.
In normal execution, it is impossible to know those instructions responsible for buffer overflows and 
memory usage-after-free errors if we do not check every memory access. 
Checking every memory access obviously introduces significant performance overhead, which \doubletake{} avoids. 
It is expensive to acquire call stacks for every memory allocation for detecting memory leakage, \doubletake{} leaves this operation to re-execution phase when memory leakage is detected.
By doing this, \doubletake{} enables programs to run with very low overhead until an error is detected.

\subsubsection*{Preparation}
\doubletake{} does some preparation before it rolls back and re-execute a program with memory errors. 
In order to locate instructions responsible for buffer overflows and memory usage-after-free errors,
\doubletake{} installs watch points on addresses with corrupted canaries, as described in Section~\ref{sec:applications}.
Hardware watch points are configured with debug registers, 
but these registers are only accessible to the kernel. 
Using \texttt{ptrace} function, \doubletake{} forks a child process to install watch points for current process.  

To find the allocation sites and de-allocation sites for memory usage-after-free errors and memory leakage problems, 
\doubletake{} puts all suspected heap objects into a hash map, which are checked for every memory allocation and deallocation. 

Additionally, \doubletake{} calls \texttt{lseek} to recover file positions of all opening files.

\subsubsection*{Rollback}
Regardless of the error detection being used, \doubletake{} must roll back program state 
before the epoch with errors can be re-executed. Before the program stack can be restored, \doubletake{} must switch to a temporary stack since the stack restore process may overwrite its own stack. Next, \doubletake{} restores the state of all writable memory from the epoch's snapshot. Finally, \doubletake{} restores register state with the \texttt{setcontext()} function and re-execution proceeds automatically.

\subsubsection*{Re-Execution}
The main task of re-execution is to collect additional information about different memory errors, which
have been discussed in Section~\ref{sec:applications}. 
In re-execution phase, \doubletake{} repeats the results of recordable system calls by reusing results recorded in normal execution.
For delayable system calls, \doubletake{} turns them to no-op in the re-execution phase.  
